#!/usr/bin/env python
import estagio
import sys
import mysql.connector
import glob
import pandas as pd
import numpy as np

"""
	This script adds the contents of any files that were generated by SATs (Cppcheck, Flawfinder) to four different tables in
	the database: 'sat', 'rule', 'rule_cwe_info', 'alert'. The 'cwe_info' table currently does not need to be created before
	running this script. Only files in the 'sat-results' directory that start with 'cppcheck-' or 'flawfinder-' are loaded.

	Requirements:

	pip install mysql-connector-python
	pip install pandas
	pip install xlrd
	pip install numpy
"""

database_config = estagio.load_database_config()

try:
	print('Connecting to the database...')
	connection = mysql.connector.connect(**database_config)
	cursor = connection.cursor(prepared=True)
except mysql.connector.Error as error:
	error_string = repr(error)
	print(f'Failed to connect to the database with the error: {error_string}')
	sys.exit(1)

# --------------------------------------------------

DROP_SAT_TABLES_BEFORE_RUNNING = True

if DROP_SAT_TABLES_BEFORE_RUNNING:

	try:
		print('Dropping all SAT related tables...')
		cursor.execute(	'''
							DROP TABLE IF EXISTS sat, rule, rule_cwe_info, alert;
						''')

		connection.commit()
	except mysql.connector.Error as error:
		error_string = repr(error)
		print(f'Failed to drop all SAT related tables with the error: {error_string}')
		sys.exit(1)

# --------------------------------------------------

try:
	print('Creating the SAT table...')
	cursor.execute(	'''
						CREATE TABLE IF NOT EXISTS sat
						(
							SAT_ID INTEGER AUTO_INCREMENT PRIMARY KEY,
							SAT_NAME VARCHAR(50) NOT NULL UNIQUE
						);
					''')

	connection.commit()
except mysql.connector.Error as error:
	error_string = repr(error)
	print(f'Failed to create the SAT table with the error: {error_string}')
	sys.exit(1)

# --------------------------------------------------

try:
	print('Creating the Rules table...')
	cursor.execute(	'''
						CREATE TABLE IF NOT EXISTS rule
						(
							RULE_ID INTEGER AUTO_INCREMENT PRIMARY KEY,
							RULE_NAME VARCHAR(100) NOT NULL UNIQUE,
							RULE_CATEGORY VARCHAR(50) NOT NULL,

							SAT_ID INTEGER NOT NULL,
							
							FOREIGN KEY (SAT_ID) REFERENCES sat(SAT_ID) ON DELETE RESTRICT ON UPDATE RESTRICT
						);
					''')

	connection.commit()
except mysql.connector.Error as error:
	error_string = repr(error)
	print(f'Failed to create the Rules table with the error: {error_string}')
	sys.exit(1)

# --------------------------------------------------

try:
	print('Creating the Rules to CWE Info table...')
	cursor.execute(	'''
						CREATE TABLE IF NOT EXISTS rule_cwe_info
						(
							RULE_ID INTEGER,
							V_CWE INTEGER,
							
							PRIMARY KEY (RULE_ID, V_CWE),

							FOREIGN KEY (RULE_ID) REFERENCES rule(RULE_ID) ON DELETE RESTRICT ON UPDATE RESTRICT
						);
					''')

	# For now, we'll remove this foreign key relationship since we would otherwise be unable to add CWE values
	# that don't already exist in the 'cwe_info' table.
	# FOREIGN KEY (V_CWE) REFERENCES cwe_info(V_CWE) ON DELETE RESTRICT ON UPDATE RESTRICT

	connection.commit()
except mysql.connector.Error as error:
	error_string = repr(error)
	print(f'Failed to create the Rules to CWE Info table with the error: {error_string}')
	sys.exit(1)

# --------------------------------------------------

try:
	print('Creating the Alerts table...')
	cursor.execute(	'''
						CREATE TABLE IF NOT EXISTS alert
						(
							ALERT_ID INTEGER AUTO_INCREMENT PRIMARY KEY,
							ALERT_SEVERITY_LEVEL INTEGER,
							ALERT_LINE INTEGER NOT NULL,
							ALERT_MESSAGE VARCHAR(1000),

							RULE_ID INTEGER NOT NULL,
							ID_File INTEGER NOT NULL,
							
							FOREIGN KEY (RULE_ID) REFERENCES rule(RULE_ID) ON DELETE RESTRICT ON UPDATE RESTRICT
						);
					''')

	connection.commit()
except mysql.connector.Error as error:
	error_string = repr(error)
	print(f'Failed to create the Alerts table with the error: {error_string}')
	sys.exit(1)

# --------------------------------------------------

def insert_rule_and_alert_into_database(cursor, index,
										sat_name, rule_name, rule_category, rule_cwe_list,
										alert_line, alert_message, alert_file_path):
	
	try:
		print(f'- Inserting the rule "{rule_name}"...')

		cursor.execute(	'''
							INSERT IGNORE INTO rule (RULE_NAME, RULE_CATEGORY, SAT_ID)
							VALUES
							(
								%s,
								%s,
								(SELECT SAT_ID FROM sat WHERE SAT_NAME = %s LIMIT 1)
							);
						''',
						(rule_name, rule_category, sat_name))

		connection.commit()
	except mysql.connector.Error as error:
		error_string = repr(error)
		print(f'Failed to insert the rule "{rule_name}" with the error: {error_string}')

	try:
		rule_cwe_list = [(rule_name, cwe) for cwe in cwe_list]

		if len(cwe_list) > 0:
			print(f'- Inserting the CWEs...')
			print(cwe_list)

		cursor.executemany(	'''
								INSERT IGNORE INTO rule_cwe_info (RULE_ID, V_CWE)
								VALUES
								(
									(SELECT RULE_ID FROM rule WHERE RULE_NAME = %s LIMIT 1),
									%s
								);
							''',
							rule_cwe_list)

		connection.commit()
	except mysql.connector.Error as error:
		error_string = repr(error)
		print(f'Failed to insert the rule "{rule_name}" with the error: {error_string}')

	try:
		print(f'- Inserting the alert #{index} from the file "{alert_file_path}"...')

		cursor.execute(	'''
							INSERT INTO alert (ALERT_LINE, ALERT_MESSAGE, RULE_ID, ID_File)
							VALUES
							(
								%s,
								%s,
								(SELECT RULE_ID FROM rule WHERE RULE_NAME = %s LIMIT 1),
								(
									SELECT ID_File FROM
									(
										SELECT * FROM files_1_dom
										UNION ALL
										SELECT * FROM files_1_javascript
										UNION ALL
										SELECT * FROM files_1_javascript_extras
										UNION ALL
										SELECT * FROM files_1_javascript_xpconnect
										UNION ALL
										SELECT * FROM files_1_layout_rendering
										UNION ALL
										SELECT * FROM files_1_libraries
										UNION ALL
										SELECT * FROM files_1_mozilla
										UNION ALL
										SELECT * FROM files_1_network
										UNION ALL
										SELECT * FROM files_1_toolkit
										UNION ALL
										SELECT * FROM files_1_webpage_structure
										UNION ALL
										SELECT * FROM files_1_widget
									) all_files
									WHERE FilePath = %s
									LIMIT 1
								)
							);
						''',
						(alert_line, alert_message, rule_name, alert_file_path))

		connection.commit()
	except mysql.connector.Error as error:
		error_string = repr(error)
		print(f'Failed to insert the alert #{index} with the error: {error_string}')

	print()

# --------------------------------------------------
print()

SAT_RESULTS_DIRCTORY = 'sat-results'
SAT_NAMES = ['Cppcheck', 'Flawfinder']

try:
	print('Inserting the following SATs in the SAT table:')
	print(SAT_NAMES)
	
	name_list = [(name,) for name in SAT_NAMES]
	cursor.executemany(	'''
							INSERT IGNORE INTO sat (SAT_NAME)
							VALUES (%s);
						''',
						name_list)

	connection.commit()
except mysql.connector.Error as error:
	error_string = repr(error)
	print(f'Failed to insert the SATs with the error: {error_string}')
	sys.exit(1)

print()
print(f'---> Adding SAT results to the database:')
print()

cppcheck_results = glob.iglob(fr'{SAT_RESULTS_DIRCTORY}\cppcheck-*')

for results_path in cppcheck_results:
	
	# For now, we'll assume it's an Excel .xlsx file.
	results = pd.read_excel(results_path, sheet_name='All Alerts', na_values=['None', 'CWE not found'], dtype={'cwe': str})

	# Replace any N/A values with None.
	results = results.replace({np.nan: None})

	# For testing purposes: only insert every 4000th alert.
	results = results[::5000]

	print(f'Adding the {len(results)} Cppcheck results from "{results_path}"...')
	print()

	for index, row in results.iterrows():

		commit = row['commit']
		filename_loc = row['filename-loc']
		category = row['severity']
		rule_name = row['id']
		message = row['message']
		cwe = row['cwe']

		file_path, line = filename_loc.split(':', 1)
		
		cwe_list = [cwe] if cwe is not None else []

		insert_rule_and_alert_into_database(cursor, index,
											'Cppcheck', rule_name, category, cwe_list,
											line, message, file_path)

print()

flawfinder_results = glob.iglob(fr'{SAT_RESULTS_DIRCTORY}\flawfinder-*')

for results_path in flawfinder_results:
	
	results = pd.read_csv(results_path)

	# Remove results that don't have a rule.
	results = results.dropna(subset=['Name'])

	# Replace any N/A values with None.
	results = results.replace({np.nan: None})

	# For testing purposes: only insert every 1000th alert.
	results = results[::1000]

	print(f'Adding the {len(results)} Flawfinder results from "{results_path}"...')
	print()

	for index, row in results.iterrows():

		file_path = row['File']
		line = row['Line']
		column = row['Column']
		severity_level = row['Level']
		category = row['Category']
		rule_name = row['Name']
		warning = row['Warning']
		suggestion = row['Suggestion']
		note = row['Note']
		cwe_list = row['CWEs']
		context = row['Context']
		context_hash = row['Fingerprint']

		# Remove the "/opt/josep/gecko-dev/" prefix.
		file_path = file_path.split('/', 4)[4]

		# Get a list of CWEs. The following values may appear:
		# - 'CWE-676, CWE-120, CWE-20'
		# - 'CWE-362/CWE-367!'
		# - 'CWE-119!/CWE-120'
		if '/' in cwe_list:
			cwe_list = [cwe.split('-', 1)[1].rsplit('!', 1)[0] for cwe in cwe_list.split('/')]
		else:
			cwe_list = [cwe.split('-', 1)[1] for cwe in cwe_list.split(',')]

		insert_rule_and_alert_into_database(cursor, index,
											'Flawfinder', rule_name, category, cwe_list,
											line, warning, file_path)

print()
print('Finished running.')
