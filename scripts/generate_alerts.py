#!/usr/bin/env python3

"""
	This script generates the security alerts for any files affected by vulnerabilities associated with the five C/C++ projects.
	
	This information includes the file's path, whether it was vulnerable or not, the associated Git commit where this specific
	file version originated from, and various different security alerts generated by SATs (at a file, function, and class level).

	This script uses the CSV files generated after running "find_affected_files.py" to creates its own CSVs.
"""

import pandas as pd # type: ignore

from modules.common import log, append_dataframe_to_csv, check_range_overlap, delete_file, replace_in_filename, serialize_json_container
from modules.sats import CppcheckSat
from modules.project import Project

####################################################################################################

project_list = Project.get_project_list_from_config()

Project.debug_ensure_all_project_repositories_were_loaded(project_list)

for project in project_list:

	cppcheck = CppcheckSat(project)

	for input_csv_path in project.find_output_csv_files('affected-files'):

		log.info(f'Generating the alerts for the project "{project}" using the information in "{input_csv_path}".')

		temp_csv_path = replace_in_filename(input_csv_path, 'affected-files', 'temp-cppcheck')
		output_csv_path = replace_in_filename(input_csv_path, 'affected-files', 'alerts-cppcheck')

		delete_file(temp_csv_path)
		delete_file(output_csv_path)

		for (commit_hash, is_commit_vulnerable, full_file_path_list, relative_file_path_list, file_path_to_functions, file_path_to_classes) in project.iterate_and_checkout_affected_files_in_repository(input_csv_path):

			cppcheck_success = cppcheck.generate_project_alerts(full_file_path_list, temp_csv_path)

			if cppcheck_success:
				alerts = pd.read_csv(temp_csv_path, dtype=str)

				alerts.insert(0, 'Vulnerable Commit', None)
				alerts.insert(1, 'Commit Hash', None)
				alerts.insert(2, 'Affected Functions', None)
				alerts.insert(3, 'Affected Classes', None)
				alerts.insert(4, 'Vulnerable File', None)

				alerts['Vulnerable Commit'] = 'Yes' if is_commit_vulnerable else 'No'
				alerts['Commit Hash'] = commit_hash
				
				for row in alerts.itertuples():
					
					if pd.isna(row.File) or pd.isna(row.Line):
						log.warning('The following alert is missing its file or line number: ' + row)
						continue
					# Exclude any code units that are associated with a file that was not changed in this commit.
					elif row.File not in relative_file_path_list:
						continue

					function_list = file_path_to_functions[row.File]
					class_list = file_path_to_classes[row.File]
					alert_lines = [int(row.Line), int(row.Line)]

					affected_function_list = []
					affected_class_list = []

					for unit in function_list:
						if check_range_overlap(unit['Lines'], alert_lines):
							affected_function_list.append(unit)

					for unit in class_list:
						if check_range_overlap(unit['Lines'], alert_lines):
							affected_class_list.append(unit)

					alerts.at[row.Index, 'Affected Functions'] = serialize_json_container(affected_function_list)
					alerts.at[row.Index, 'Affected Classes'] = serialize_json_container(affected_class_list)
					alerts.at[row.Index, 'Vulnerable File'] = row[1]

				append_dataframe_to_csv(alerts, output_csv_path)

			delete_file(temp_csv_path)

	log.info(f'Finished running for the project "{project}".')

print('Finished running.')
